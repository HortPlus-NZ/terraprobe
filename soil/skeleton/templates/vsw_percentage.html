<!-- templates/vsw_percentage.html -->

{% load static %}
{% block content %}

<h5 align="center">{{ title }} Reading date: {{ date }} Period From: {{ period_from }} Period To: {{ period_to }}</h5>
<!-- Initialize a select button -->
<select id="selectButton"></select>
<div class="row">
    <div class="col-4" id="weekly"></div>
    <div class="col-1">
        <figure class='highcharts-figure-soil-profile'>
            <div id='soil-profile' class='chart-soil-profile'></div>
        </figure>
    </div>
    <div class="container col-7">
    <div class="row">
    <div class="col-6" id="area3">
        <table id="last-week-data" class="table table-sm table-bordered">
            <thead class="thead-light">
            <tr>
                <th colspan="4" class="application-rate-heading"></th>
            </tr>
            <tr>
                <td></td>
                <td>mm/plant</td>
                <td>Litres/plant</td>
                <td>Hours</td>
            </tr>
            <tr>
                <td>Irrigation</td>
                <td class="mms-plant"></td>
                <td class="litres-plant"></td>
                <td class="hours"></td>
            </tr>
            <tr>
                <td>Rain (mm)</td>
                <td class="previous-rain"></td>
                <td>Root Zone</td>
                <td class="root-zone">cm</td>
            </tr>
            <tr>
                <td>Estimated 7 day water use</td>
                <td class="weekly-edwu"></td>
                <td>Reviewed</td>
                <td class="recommendation-reviewed"></td>
            </tr>
        </table>
        <table id="season-data" class="table table-sm table-bordered">
            <thead class="thead-light">
            <tr>
                <th colspan="4">Season To Date mm</th>
            </tr>
            <tr>
                <td>Irrigation</td>
                <td class="std-irrigation"></td>
                <td>Rain</td>
                <td class="std-rain"></td>
            </tr>
        </table>
    </div>
    <div class="col-6" id="area4">
        <form>
            <textarea class="form-control form-control-sm" rows="3" id="reading-recommendation-text" readonly></textarea>
            <div id='week-day-labels' class="input-group">
                <input type="text" class="form-control" id="Mon-label" placeholder="Mon" readonly>
                <input type="text" class="form-control" id="Tue-label" placeholder="Tue" readonly>
                <input type="text" class="form-control" id="Wed-label" placeholder="Wed" readonly>
                <input type="text" class="form-control" id="Thu-label" placeholder="Thu" readonly>
                <input type="text" class="form-control" id="Fri-label" placeholder="Fri" readonly>
                <input type="text" class="form-control" id="Sat-label" placeholder="Sat" readonly>
                <input type="text" class="form-control" id="Sun-label" placeholder="Sun" readonly>
            </div>
            Hours
            <div id='week-days' class="input-group">
                <input type="text" class="form-control" id="Mon" placeholder="Mon" readonly>
                <input type="text" class="form-control" id="Tue" placeholder="Tue" readonly>
                <input type="text" class="form-control" id="Wed" placeholder="Wed" readonly>
                <input type="text" class="form-control" id="Thu" placeholder="Thu" readonly>
                <input type="text" class="form-control" id="Fri" placeholder="Fri" readonly>
                <input type="text" class="form-control" id="Sat" placeholder="Sat" readonly>
                <input type="text" class="form-control" id="Sun" placeholder="Sun" readonly>
             </div>
             mm
             <div id='week-days-water' class="input-group">
                 <input type="text" class="form-control" id="Mon-water" readonly>
                 <input type="text" class="form-control" id="Tue-water" readonly>
                 <input type="text" class="form-control" id="Wed-water" readonly>
                 <input type="text" class="form-control" id="Thu-water" readonly>
                 <input type="text" class="form-control" id="Fri-water" readonly>
                 <input type="text" class="form-control" id="Sat-water" readonly>
                 <input type="text" class="form-control" id="Sun-water" readonly>
             </div>
         </form>
    </div>
    <div class="col-8" id="area5">
       <iframe id="widget-iframe" width="1100" height="125" src="/weather" allowtransparency="true" style="border:none"></iframe>
   </div>
    </div>
    </div>


</div>
<div class="row">
    <div class="col" id="seasonal"></div>
    <div class="col">
        <figure class='highcharts-figure-irrigation-gauge'>
            <div id='irrigation-gauge' class='irrigation-gauge'></div>
        </figure>
    </div>
</div>
<div class="row">
    <div class="col" id="seasonal_bar"></div>
    <div class="col" id="alert-box">
        <textarea id="site-note" rows="4" cols="30" style="border:2px solid red;" readonly>
        </textarea>
    </div>
</div>

<script>
console.clear();
var parseTime = d3.timeParse("%d-%m-%Y");
var formatTime = d3.timeFormat("%d-%m-%Y");

// assemble reading date and previous reading date into this and last weeks dates javascript dates. Time does not matter
// js is a bitch extract on '-' for date 25-03-2019
var date = "{{ date }}";
var this_week_date = formatTime(parseTime(date));
var split_date = date.split("-");
var this_week_date_test = new Date(split_date[2], split_date[1] - 1, split_date[0]);

console.log("***This week DATE:" + this_week_date);
var last_week_exists = false
var previous = "{{ previous }}";
if (previous != 'None') {
    last_week_date = formatTime(parseTime(previous));
    console.log('***Last Week DATE:' + last_week_date);
    last_week_exists = true;
}

var period_to = "{{ period_to }}";
period_to = formatTime(parseTime(period_to));
period_to = parseTime(period_to);

var period_from = "{{ period_from }}";
period_from = formatTime(parseTime(period_from));
period_from = parseTime(period_from);

var site_id = "{{ site_id }}";
var season_id = "{{ season_id }}";

// set the dimensions and margins of the weekly graph
var margin = {top: 35, right: 30, bottom: 30, left: 40};
width = 600 - margin.left - margin.right;
height = 350 - margin.top - margin.bottom;

// set the dimensions and margins of the season graph
//var season_margin = {top: 500, right: 20, bottom: 30, left: 50};
season_width = 1400 - margin.left - margin.right;
season_height = 420 - margin.top - margin.bottom;
season_bar_height = 250 - margin.top - margin.bottom;

// set the weekly ranges
var weekly_x = d3.scaleLinear().range([0, width]);
var weekly_y = d3.scaleLinear().range([0, height]);

// set the season ranges
var seasonx = d3.scaleTime().range([0, season_width]);

var seasony0 = d3.scaleLinear().range([season_height, 0]);
var season_bar_y1 = d3.scaleLinear().range([season_bar_height, 0]);

var season_bar_z = d3.scaleOrdinal()
    .range(["blue", "red"]);

var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

/******************** Weekly Graph Lines *********************/

var vswline = d3.line()
    .x(function(r) { return weekly_x(r.vsw); })
    .y(function(r) { return weekly_y(r.depth); });

var previous_vswline = d3.line()
    .x(function(r) { return weekly_x(r.vsw); })
    .y(function(r) { return weekly_y(r.depth); });

var refill_line = d3.line()
    .x(function(r) { return weekly_x(r.vsw); })
    .y(function(r) { return weekly_y(r.depth); });

var full_point_line = d3.line()
    .x(function(r) { return weekly_x(r.vsw); })
    .y(function(r) { return weekly_y(r.depth); });

var weekly_graph = d3.select("#weekly").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

/******************** Season Graph Lines *********************/

var season_vswline0 = d3.line()
    .x(function(r) { return seasonx(r.date); })
    .y(function(r) { return seasony0(r.total); });

var season_upper_strategy_line = d3.line()
    .x(function(r) { return seasonx(r.date); })
    .y(function(r) { return seasony0(r.total); });

var season_lower_strategy_line = d3.line()
    .x(function(r) { return seasonx(r.date); })
    .y(function(r) { return seasony0(r.total); });

var season_full_point_line = d3.line()
    .x(function(r) { return seasonx(r.date); })
    .y(function(r) { return seasony0(r.total); });

var season_refill_line = d3.line()
    .x(function(r) { return seasonx(r.date); })
    .y(function(r) { return seasony0(r.total); });

var season_graph = d3.select("#seasonal").append("svg")
    .attr("width", season_width + margin.left + margin.right)
    .attr("height", season_height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

/******************** Season Bar Graph Lines *********************/

var season_bar_graph = d3.select("#seasonal_bar").append("svg")
    .attr("width", season_width + margin.left + margin.right)
    .attr("height", season_bar_height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

// Weeks readings arrays
var site = {}
var weekly_vsw_map = {}
var full_point_readings = [];
var refill_readings = [];

// Seasons readings arrays
var seasons_vsw_readings = [];
var seasons_full_point_readings = []
var seasons_refill_readings = []
var seasons_upper_strategy = []
var seasons_lower_strategy = []
var strategy_percentage = 0

var season_grouping = [];
vsw_count = 10; // delivered by vsw_reading api
var full_point_rz1 = 0;
var refill_rz1 = 0;

var season_critical_dates = {};

// Recommedations
var weekly_rain = 0;
var weekly_hours_irrigation = 0;
var weekly_mms_plant = 0;
var weekly_litres_plant = 0;
var std_irrigation = 0;
var std_rain = 0;
var root_zone = '0 - ';
var weekly_edwu = 0;
var recommendation_text = '';
var site_note = '';
var rooting_barrier = 0;
var recommendation_reviewed = false
var rec_mon = 0, rec_tue = 0, rec_wed = 0, rec_thu = 0, rec_fri = 0, rec_sat = 0, rec_sun = 0;

// Irrigation gauge
var strategy_max = 0;
var strategy_min = 0;
var latest_reading = 0;

function sortByDateAscending(a, b) {
    // Dates will be cast to numbers automagically:
    return a.date - b.date;
}

promises = get_graph_data(site_id, period_from, period_to, season_id)

Promise.all(promises).then(function(values) {

    values[1].forEach(function(strategy) {

        season_critical_dates[strategy.critical_date_type] = [{
            'date': parseTime(strategy.critical_date),
            'id': strategy.criticaldate_id
        }];
        //[strategy.critical_date_type] = parseTime(strategy.critical_date);

        strategy_percentage = strategy.strategy_percentage; // This is the overall strategy percentage for the strategy type
        parsed_date = parseTime(strategy.strategy_date);

        seasons_upper_strategy.push({
            'date' : parsed_date,
            'percentage' : strategy.percentage
        });
        seasons_lower_strategy.push({
            'date' : parsed_date,
            'percentage' : 0
        });
    }); // End loop of strategy data

    site = values[2];
    site_note = site.comment;
    application_rate = site.application_rate;
    rooting_barrier = site.rooting_barrier

    // Get profiles. Works much like the depths so use vsw count to get them all
    soil_profiles = []
    for (index = 1; index <= vsw_count; index++) {
        if (site["profile" + index] !== null) {
            soil_profile = site["profile" + index]
            soil_profiles.push({
                'name' : soil_profile.name,
                'color' : soil_profile.color,
                'depth' : site["depth" + index]
            });
        }
    }

    // This is a single site display so we always get the first site
    site = values[3].sites[0];

    strategy_max = site.strategy_max;
    strategy_min = site.strategy_min;
    latest_reading = site.latest_reading_date_rz1;
    irrigation_gauge_top = site.irrigation_gauge_top;
    irrigation_gauge_middle = site.irrigation_gauge_middle;
    irrigation_gauge_bottom = site.irrigation_gauge_bottom;
    irrigation_gauge_percentage = site.irrigation_gauge_percentage;

    values[0].forEach(function(reading) {
        parsed_date = parseTime(reading.date);
        // get seasons_vsw percentage readings for Probe
        if (reading.type == "Probe") {
            seasons_vsw_readings.push({
                'date' : parsed_date,
                'total' : Math.round(reading["rz1"]),
            });
            season_grouping.push({
                'date' : parsed_date,
                'rain' : reading["rain"],
                'irrigation_mms' : reading["irrigation_mms"],
            });

            // Season to Date figures
            std_irrigation += reading["irrigation_mms"]
            std_rain += reading["rain"]

            // Weekly vsw figures. This will be a map, keyed by date
            var vsw_readings = [];
            for (index = 1; index <= vsw_count; index++) {
                if (reading["depth" + index] !== null) {
                    vsw_readings.push({
                        'depth' : reading["depth" + index],
                        'vsw' : reading["vsw" + index + '_perc'],
                    });
                }
                weekly_vsw_map[formatTime(parsed_date)] = vsw_readings;
            } // end for loop
            if (this_week_date == formatTime(parsed_date) ) {
                console.log("** Reading Date:" + parsed_date + " This week date:" + this_week_date)

                // get recommendation and other data for this week
                recommendation_text = reading["comment"]
                recommendation_reviewed = reading["reviewed"]
                if (recommendation_reviewed === false) {
                    recommendation_reviewed = 'false';
                }

                rec_mon = reading["rec_mon"]
                rec_tue = reading["rec_tue"]
                rec_wed = reading["rec_wed"]
                rec_thu = reading["rec_thu"]
                rec_fri = reading["rec_fri"]
                rec_sat = reading["rec_sat"]
                rec_sun = reading["rec_sun"]
                root_zone += reading["rz1_bottom"] + ' cm';
                root_zone1_bottom = reading["rz1_bottom"]
                weekly_edwu = reading["weekly_edwu"];

                weekly_litres_plant = reading["irrigation_litres"];
                weekly_mms_plant = reading["irrigation_mms"];
                weekly_rain = reading["rain"];
            }
        }

        // Get the Full Point and Refill - These are the vsw figures
        if (reading.type == "Full Point") {
            for (index = 1; index <= vsw_count; index++) {
                if (reading["depth" + index] !== null) {
                    full_point_readings.push({
                        'depth' : reading["depth" + index],
                        'vsw' : reading["vsw" + index],
                    });
                }
            }
            full_point_rz1 = Math.round(reading["rz1"]);
        }

        if (reading.type == "Refill") {
            for (index = 1; index <= vsw_count; index++) {
                if (reading["depth" + index] !== null) {
                    refill_readings.push({
                        'depth' : reading["depth" + index],
                        'vsw' : reading["vsw" + index],
                    });
                }
            }
            refill_rz1 = Math.round(reading["rz1"]);
        }
    }); // End reading loop

    weekly_hours_irrigation = Math.round(weekly_mms_plant / application_rate);

    // https://www.d3-graph-gallery.com/graph/line_filter.html
    // Selct Button for Weekly Graph
    var allGroup = d3.map(weekly_vsw_map, function(r){return(r.date)}).keys()

    d3.select("#selectButton")
      .selectAll('myOptions')
        .data(allGroup)
      .enter()
        .append('option')
      .text(function (r) { return r; }) // text showed in the menu
      .attr("value", function (r) { return r; }) // corresponding value returned by the button

    // Seasons Refill - This is the rz1 value for each proble reading date
    seasons_refill_readings.push({
        'date' : period_from,
        'total' : refill_rz1
    });
    seasons_refill_readings.push({
        'date' : period_to,
        'total' : refill_rz1
    });
    seasons_full_point_readings.push({
        'date' : period_from,
        'total' : full_point_rz1
    });
    seasons_full_point_readings.push({
        'date' : period_to,
        'total' : full_point_rz1
    });

    /* need to sort arrays by date */
    seasons_vsw_readings = seasons_vsw_readings.sort(sortByDateAscending);

    // TODO: Do this better. Need to test if site actually has a strategy
    if (seasons_upper_strategy.length > 0) {
        diff = full_point_rz1 - refill_rz1

        for (var i = 0; i < seasons_upper_strategy.length; i++) {
            upper_total = full_point_rz1 - (diff - (diff * seasons_upper_strategy[i]['percentage']))

            lower_total = upper_total - ( diff * strategy_percentage )
            seasons_upper_strategy[i]['total'] = upper_total;
            seasons_lower_strategy[i]['date'] = seasons_upper_strategy[i]['date'];
            seasons_lower_strategy[i]['total'] = lower_total;
        }
    }
    seasons_upper_strategy = seasons_upper_strategy.sort(sortByDateAscending);
    seasons_lower_strategy = seasons_lower_strategy.sort(sortByDateAscending);
    season_grouping  = season_grouping.sort(sortByDateAscending);

    // Scale the range of the data
    var min_weekly_x = 0;
    if (last_week_exists) {
        min_weekly_x = refill_readings.concat(weekly_vsw_map[this_week_date]).concat(weekly_vsw_map[last_week_date]);
    } else {
        min_weekly_x = refill_readings.concat(weekly_vsw_map[this_week_date])
    }
    weekly_x.domain([d3.min(min_weekly_x, function(r) { return r.vsw - 2; }), d3.max(full_point_readings, function(r) { return r.vsw + 2; })]);
    weekly_y.domain([d3.min(weekly_vsw_map[this_week_date], function(r) { return r.depth - 5; }), d3.max(weekly_vsw_map[this_week_date], function(r) { return r.depth + 5; })]);

    // Min and max for seasony and then set domain on it. Max could be full point of vsw, min could be refill or vsw
    vsws = seasons_vsw_readings.map(d => d.total); // get the vsw readings for the season

    max = Math.max(...vsws)
    min = Math.min(...vsws)
    max_seasony = 0
    min_seasony = 0
    if (max >= full_point_rz1){ max_seasony = max } else { max_seasony = full_point_rz1 }
    if (min <= refill_rz1){ min_seasony = min } else { min_seasony = refill_rz1 }

    seasony0.domain([min_seasony - 50, max_seasony + 20]);

    /*********************** Weekly Graph Shaded Area between This Week and Previous weeks line ********************/
    // We need to get data into arrays for x and y for this week and x for previous week

    var this_week_x = [];
    var this_week_y = [];
    var previous_week_x = [];
    weekly_area = 0;
    if (last_week_exists) {
        for (i=0; i < weekly_vsw_map[last_week_date].length; i++) {
            this_week_y.push(weekly_vsw_map[this_week_date][i].depth);
            this_week_x.push(weekly_vsw_map[this_week_date][i].vsw);
            previous_week_x.push(weekly_vsw_map[last_week_date][i].vsw);
        }

        // Append the shaded area to graph
        var indexies = d3.range( this_week_y.length );
        var weekly_area = weekly_graph
           .append('g')
           .append("path")
           .datum(indexies)
           .attr("d", d3.area()
               .x0(function(d) { return weekly_x(this_week_x[d]) })
               .x1(function(d) { return weekly_x(previous_week_x[d]) ; })
               .y0(function(d) { return weekly_y(this_week_y[d] ); })
               .y1(function(d) { return weekly_y(this_week_y[d] ); })
            )
           .attr("class", "area");
    }
    // End Shaded Area

    var weekly_vswline = weekly_graph
        .append('g')
        .append("path")
        .datum(weekly_vsw_map[this_week_date])
        .attr("d", d3.line()
            .x(function(r) { return weekly_x(r.vsw); })
            .y(function(r) { return weekly_y(r.depth); })
        )
        .attr("class", "line");

    if (last_week_exists) {
        var weekly_previous_vswline = weekly_graph
            .append('g')
            .append("path")
            .datum(weekly_vsw_map[last_week_date])
            .attr("d", d3.line()
                .x(function(r) { return weekly_x(r.vsw); })
                .y(function(r) { return weekly_y(r.depth); })
            )
            .style("stroke-width", "1px")
            .attr("class", "line");
    }

    // Add the scatterplot
    var weekly_scatterplot = weekly_graph
        .append('g')
        .selectAll("dot")
        .data(weekly_vsw_map[this_week_date])
        .enter().append("circle")
            .attr("r", 5)
            .attr("cx", function(r) { return weekly_x(r.vsw); })
            .attr("cy", function(r) { return weekly_y(r.depth); });

    // Add the refill line
    weekly_graph.append("path")
      .data([refill_readings])
      .attr("class", "line")
      .style("stroke", "red")
      .attr("d", refill_line);

    // Add the full point line
    weekly_graph.append("path")
        .data([full_point_readings])
        .attr("class", "line")
        .style("stroke", "green")
        .attr("d", full_point_line);

    // Add a line for the bottom of root zone 1
    weekly_graph.append("line")
        .attr("x1", 0)
        .attr("y1", weekly_y(root_zone1_bottom))
        .attr("x2", width)
        .attr("y2", weekly_y(root_zone1_bottom))
        .style("stroke-width", 2)
        .style("stroke-dasharray", ("5, 5"))
        .style("stroke", 'blue')
        .style("fill", "none");

    weekly_graph.append("text")
        .attr("y", weekly_y(root_zone1_bottom))
        .attr("x", width + 17)
        .attr('text-anchor', 'middle')
        .attr("class", "lineLabel")
        .text('RZ1');

    // Add the X Axis
    weekly_graph.append("g")
      .call(d3.axisTop(weekly_x));

    weekly_graph.append("text")
      .attr("transform",
            "translate(" + (width/2) + " ," +
                           (0 - 20) + ")")
      .text("VSW (%)");

    // Add the Y Axis
    weekly_graph.append("g")
        .call(d3.axisLeft(weekly_y));

    weekly_graph.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x", 0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Depth (cm)");
    seasonx.domain([period_from, period_to]);

    // We use our season critical dates to draw vertical lines. We can have 1..n
    colours = ["navy", "salmon", "orchid", "lime", "aqua", "magenta"]
    colours_count = 0;

    for (type in season_critical_dates) {
        for (var i = 0; i < season_critical_dates[type].length; i++) {
            var critical_date = season_critical_dates[type][i].date;
            var critical_date_id = season_critical_dates[type][i].id;

            season_graph.append("line")
                .attr("x1", seasonx(critical_date))
                .attr("y1", 0)
                .attr("x2", seasonx(critical_date))
                .attr("y2", season_height)
                .style("stroke-width", 2)
                .style("stroke", colours[colours_count])
                .style("fill", "none");

            season_graph.append("text")
               .attr("y", -30)
               .attr("x", seasonx(critical_date))
               .attr('text-anchor', 'left')
               .attr("class", "lineLabel")
               .text(type + "\n" + formatTime(critical_date))
               .attr("transform", "rotate(90," + seasonx(critical_date) + ",-30)")
               .attr("id", critical_date_id);
            colours_count++;
        }
    }
    // This allows user to click on critical date text and open the admin change screen for that critical data
    // This was the easiest way I could see to do with the way the lines and text are created
    season_graph.selectAll("text")
        .on("click", function(d) {
            window.open("/admin/skeleton/criticaldate/" + this.id + "/change/")
    });

    //season_graph.selectAll("text").attr("transform", "rotate(90)" );
    var tickValuesForAxis = seasons_vsw_readings.map(d => d.date);

    var keys = ['rain', 'irrigation_mms']

    var season_bar_x0 = d3.scaleTime().range([0, season_width]).domain([period_from, period_to]);
    season_bar_y1.domain([0, d3.max(season_grouping, function(d) { return d3.max(keys, function(key) { return d[key]; }); })])

    // append the rectangles for the seasonal bar chart
    season_bar_graph.selectAll(".bar")
        .data(season_grouping)
        .enter().append("g")
        .attr("class", "bar")
        .attr("transform", function(d) { return "translate(" + season_bar_x0(d.date) + ",0)"; })
        .selectAll("rect")
        .data(function(d) {
            return keys.map(function(key) {
                return { key: key, value: d[key] };
            });
        }).enter().append("rect")
          .attr('x', function(d) { if (d.key == 'rain') { return -4; } else { return 3; } } )
          .attr("y", function(d) { return season_bar_y1(d.value); })
          .attr("id", function(d) { return d.key; })
          .attr('height', function(d) { return season_bar_height - season_bar_y1(d.value); })
          .attr("width", 5)
          .on("mouseover", function(d) {
              div.transition()
              .duration(200)
              .style("opacity", .9);
              div.html(d.value)
              .style("left", (d3.event.pageX) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          })
              .on("mouseout", function(d) {
              div.transition()
              .duration(500)
              .style("opacity", 0);
          })
          .attr("fill", function(d) { return season_bar_z(d.key); });

    season_graph.append("path")
      .data([seasons_vsw_readings])
      .attr("class", "line")
      .attr("d", season_vswline0);

    season_graph.selectAll("dot")
        .data(seasons_vsw_readings)
        .enter().append("circle")
            .attr("r", 5)
            .attr("cx", function(r) { return seasonx(r.date); })
            .attr("cy", function(r) { return seasony0(r.total); })
            .on("mouseover", function(r) {
                div.transition()
                    .duration(200)
                    .style("opacity", .9);
                div.html(r.total + "<br/>" + formatTime(r.date))
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(r) {
                div.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .on("click", function(r) {
                updateWeeklyGraph(r.date)
            });

    // Full Point Season line. This is just the total of full_point_readings across all dates
    season_graph.append("path")
        .data([seasons_full_point_readings])
        .attr("class", "line")
        .style("stroke", "green")
        .style("stroke-width", "2px")
        .attr("d", season_full_point_line);

    // Refill Season line. This is just the total of refill_readings across all dates
    season_graph.append("path")
        .data([seasons_refill_readings])
        .attr("class", "line")
        .style("stroke", "red")
        .style("stroke-width", "2px")
        .attr("d", season_refill_line);

    season_graph.append("path")
        .data([seasons_upper_strategy])
        .attr("class", "line")
        .style("stroke", "black")
        .style("stroke-dasharray", ("5, 5"))
        .style("stroke-width", "3px")
        .attr("d", season_upper_strategy_line);

    season_graph.append("path")
        .data([seasons_lower_strategy])
        .attr("class", "line")
        .style("stroke", "orange")
        .style("stroke-dasharray", ("5, 5"))
        .style("stroke-width", "3px")
        .attr("d", season_lower_strategy_line);

      season_graph.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + season_height + ")")
          .call(d3.axisBottom(seasonx)
              .tickValues(tickValuesForAxis)
              .tickFormat(d3.timeFormat("%m-%d")));

      season_bar_graph.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + season_bar_height + ")")
          .call(d3.axisBottom(season_bar_x0)
            .tickValues(tickValuesForAxis)
            .tickFormat(d3.timeFormat("%m-%d")));

    // Add Season Graph Y0 Axis
    season_graph.append("g")
        .attr("class", "axisSteelBlue")
        .call(d3.axisLeft(seasony0));

    // Add Season Graph YBar Axis

    season_bar_graph.append("g")
        .attr("class", "axisRed")
        .call(d3.axisLeft(season_bar_y1));

    /*************** legend ******************/

        var legend = season_bar_graph.append("g")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "end")
        .selectAll("g")
        .data(keys.slice().reverse())
        .enter().append("g")
          .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

      legend.append("rect")
          .attr("x", season_width - 17)
          .attr("width", 15)
          .attr("height", 15)
          .attr("fill", season_bar_z)
          .attr("stroke", season_bar_z)
          .attr("stroke-width",2)
          .on("click",function(d) { update(d) });

      legend.append("text")
          .attr("x", season_width - 24)
          .attr("y", 9.5)
          .attr("dy", "0.32em")
          .text(function(d) { return d; });

      // Update recommendation fields
      $("#last-week-data td.mms-plant").html(weekly_mms_plant);
      $("#last-week-data td.litres-plant").html(weekly_litres_plant);
      $("#last-week-data td.hours").html(weekly_hours_irrigation);
      $("#last-week-data td.previous-rain").html(weekly_rain);
      $("#last-week-data td.root-zone").html(root_zone);
      $("#last-week-data td.weekly-edwu").html(weekly_edwu);
      $("#season-data td.std-irrigation").html(Math.round(std_irrigation));
      $("#season-data td.std-rain").html(Math.round(std_rain));
      $("#last-week-data td.recommendation-reviewed").html(recommendation_reviewed);
      $("#last-week-data th.application-rate-heading").html("Amount Received Last Week (Based on an irrigation system application rate of " +
          application_rate + "mm/hr)");

      var week_start = this_week_date_test.getDay();
      days = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
      week_start_abbr = days[week_start];

      $("textarea#reading-recommendation-text").val(recommendation_text);
      $("textarea#site-note").val(site_note);

      $("input#Mon").val(rec_mon);
      $("input#Tue").val(rec_tue);
      $("input#Wed").val(rec_wed);
      $("input#Thu").val(rec_thu);
      $("input#Fri").val(rec_fri);
      $("input#Sat").val(rec_sat);
      $("input#Sun").val(rec_sun);
      $("input#Mon-water").val(Math.round(application_rate * rec_mon));
      $("input#Tue-water").val(Math.round(application_rate * rec_tue));
      $("input#Wed-water").val(Math.round(application_rate * rec_wed));
      $("input#Thu-water").val(Math.round(application_rate * rec_thu));
      $("input#Fri-water").val(Math.round(application_rate * rec_fri));
      $("input#Sat-water").val(Math.round(application_rate * rec_sat));
      $("input#Sun-water").val(Math.round(application_rate * rec_sun));

      updateReadingRecommendations(week_start_abbr, week_start)

      Highcharts.setOptions({
          credits: { enabled: false },
          exporting: { enabled: false },
          legend: { enabled: false },
      });

      /**************************** Soil Profile Highcharts Stacked column ********************************/
      if (soil_profiles.length > 0) {
          var options = {
              title: {
                  text: null,
              },
              chart: { type: 'column',
                  renderTo: 'soil-profile',
                  height: 320,
                  width: 140,
              },
              xAxis: {
                  categories: [''],
              },
              yAxis: {
                  min: 0,
                  tickInterval: 10,
                  reversed: true,
                  title: {
                      text: null,
                  },
                  plotLines: [{
                    value: rooting_barrier,
                    color: 'black',
                    width: 2,
                    zIndex: 5,
                    label: { text: 'Barrier' },
                }],
              },
              plotOptions: {
                  series: {
                      groupPadding: 0
                  },
                  column: {
                      stacking: 'normal',
                      dataLabels: {
                          enabled: false
                      }
                  }
              },
              tooltip: {
                  formatter: function () {
                      return this.series.name;
                  }
              },
              series: [],
          };

        var max = 0
        var previous = 0
        soil_profiles.reverse()

        for (i=0;i < soil_profiles.length;i++) {
            if (soil_profiles[i].depth > max) max = soil_profiles[i].depth; //get max of depths

            // Work out the diff between the previous and this depth. This will populate data
            data = Math.abs(soil_profiles[i].depth - previous)
            options.series.push({
                name: soil_profiles[i].name,
                color: soil_profiles[i].color,
                data: [data],
            });
            previous = soil_profiles[i].depth
        }
        options.yAxis.max = max
        var soil_profile_chart = new Highcharts.Chart('soil-profile', options)

    } else {// End if we have soil profiles
        $("div[id='soil-profile']").append("No Soil Profiles set")
    }

    /**************************** Irrication Gauge Highcharts Stacked column ********************************/

    console.log('Irrigation Gauge Values');
    console.log('Top:', irrigation_gauge_top, 'Middle', irrigation_gauge_middle, 'Bottom', irrigation_gauge_bottom, 'Percentage', irrigation_gauge_percentage);

    var options = {
        title: {
            text: null,
        },
        chart: { type: 'column',
            renderTo: 'irrigation-gauge',
            height: 360,
            width: 150,
        },
        xAxis: {
            categories: [''],
        },
        yAxis: {
            min: -20,
            max: 120,
            opposite: true,
            tickInterval: 20,
            title: {
                text: null,
            },

            plotLines: [{
              value: irrigation_gauge_percentage,
              color: 'black',
              width: 4,
              zIndex: 5,
              label: { text: '' },
          }],
        },
        plotOptions: {
            series: {
                groupPadding: 0
            },
            column: {
                stacking: 'normal',
                dataLabels: {
                    enabled: false
                }
            }
        },
        series: [{
            name: '',
            data: [20],
            color: 'red'
        }, {
            name: '',
            data: [irrigation_gauge_top],
            color: 'orange'
        },
        {
            name: '',
            data: [irrigation_gauge_middle],
            color: 'green'
        },
        {
            name: '',
            data: [irrigation_gauge_bottom],
            color: 'orange'
        },
        {
            name: '',
            data: [-20],
            color: 'red'
        }]};

    var irrigation_gauge_chart = new Highcharts.Chart('irrigation-gauge', options)

      // Handmade legend
      /*var svg = d3.select("#legend")
        svg.append("circle").attr("cx",20).attr("cy",80).attr("r", 4).style("fill", "green")
        svg.append("circle").attr("cx",20).attr("cy",100).attr("r", 4).style("fill", "red")
        svg.append("text").attr("x", 30).attr("y", 50).text("Legend").style("font-size", "20px").attr("alignment-baseline","middle")
        svg.append("text").attr("x", 30).attr("y", 80).text("Full Point").style("font-size", "15px").attr("alignment-baseline","middle")
        svg.append("text").attr("x", 30).attr("y", 100).text("Refill").style("font-size", "15px").attr("alignment-baseline","middle")
    */
    /*
        A function that redraws the weekly chart
    */
    function redraw_weekly_graph(selectedGroup) {
          // Create new data with the selection?
          var index = allGroup.indexOf(selectedGroup)
          var this_week = allGroup[index];
          var last_week = allGroup[index - 1];

          // Give these new data to update line
          weekly_vswline
              .datum(weekly_vsw_map[this_week])
              .transition()
                .duration(1000)
                .attr("d", d3.line()
                    .x(function(r) { return weekly_x(r.vsw) })
                    .y(function(r) { return weekly_y(r.depth) })
                );

            weekly_scatterplot
                .data(weekly_vsw_map[this_week])
                .transition()
                    .duration(1000)
                    .attr("cx", function(r) { return weekly_x(r.vsw); })
                    .attr("cy", function(r) { return weekly_y(r.depth); });
            if (last_week_exists) {
                // Give these new data to update line
                weekly_previous_vswline
                    .datum(weekly_vsw_map[last_week])
                    .transition()
                    .duration(1000)
                    .attr("d", d3.line()
                      .x(function(r) { return weekly_x(r.vsw) })
                      .y(function(r) { return weekly_y(r.depth) })
                  );
                  var this_week_x = [];
                  var this_week_y = [];
                  var previous_week_x = [];
                  for (i=0; i < weekly_vsw_map[last_week].length; i++) {
                      this_week_y.push(weekly_vsw_map[this_week][i].depth);
                      this_week_x.push(weekly_vsw_map[this_week][i].vsw);
                      previous_week_x.push(weekly_vsw_map[last_week][i].vsw);
                  }

                  // Append the shaded area to graph
                  indexies = d3.range( this_week_y.length );
                  weekly_area
                     .datum(indexies)
                     .transition()
                     .duration(1000)
                     .attr("d", d3.area()
                         .x0(function(d) { return weekly_x(this_week_x[d]) })
                         .x1(function(d) { return weekly_x(previous_week_x[d]) ; })
                         .y0(function(d) { return weekly_y(this_week_y[d] ); })
                         .y1(function(d) { return weekly_y(this_week_y[d] ); })
                      )
                     .attr("class", "area");
            } // End if last week exists
    }

    // When the button is changed, run the updateChart function
    d3.select("#selectButton").on("change", function(d) {
        var selectedOption = d3.select(this).property("value");
        redraw_weekly_graph(selectedOption)
    });

    // ** Update data section
    function updateWeeklyGraph(x) {
        redraw_weekly_graph(formatTime(x))
    }

});

</script>

{% endblock content %}
