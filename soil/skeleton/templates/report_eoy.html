<!-- templates/report_eoy.html -->
{% extends 'base.html' %}
{% load static %}
{% block content %}

<h1>EOY</h1>

<div id="report">

</div>

<!--{% for data in eoy_data.eoy_data %} <p>-{{ data }}- - {{ data.rainfall }} {{ counter }}</p> {% endfor %}-->
<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/highcharts-more.js"></script>
<script src="https://code.highcharts.com/modules/solid-gauge.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>
<script src="https://code.highcharts.com/modules/export-data.js"></script>
<script src="https://code.highcharts.com/modules/accessibility.js"></script>

<script>
$(document).ready(function(){
    var farm_id = "{{ farm_id }}";

    $.ajax({
        url: "/api/eoy_farm_report/" + farm_id + "/",
        dataType: 'json',
        success: function(result) {
            console.log(result);
            var gauges = {
                'rain' : 'Rain',
                'irrigation_mms': 'Irrigation MMS',
                'eff_irrigation': 'Effective Irrigation',
                'average_eff_irrigation': 'Average Effective Irrigation',
            };

            $("#report").append("<h3>" + result[0].farm + " - 10 Year Average Rainfall mms " + result[0].average_rainfall + "</h3>")

            result.forEach(function(d) {

                /////////////////////////////////////// Start Gauges ////////////////////////////////////////////
                $("#report").append("<h4>" + d.site + " - " + d.season  + " - " + d.soil_type + " Soil - Root Zone " + d.rz1 + " - Application Rate " +
                    d.application_rate + "</h4>");

                // We need rows of highcharts gauges. So each row needs a unique identifier of site id and season eg row-238-2020-2021
                var row = '';
                row_id = 'row-' + d.site_id + "-" + d.season;
                row += "<div class='row' id='" + row_id + "'></row>"
                $("div[id='report']").append(row)

                // Loop thrugh the gauges we are going to display
                for (var key in gauges) {

                    var gauge_name = key + '-' + d.site_id + '-' + d.season; // this is unique for each gauge/chart eg. irrigation_mms-238-2020-2021
                    var gauge_data = d[key]
                    var gauge_data_diff = d[key + '_diff'];
                    var gauge_data_perc = d[key + '_perc'];

                    content = '';
                    content += "<figure class='highcharts-figure'>"
                    content += "<div id='" + gauge_name + "' class='chart-container'></div></figure>"
                    $("div[id='" + row_id + "']").append(content);

                    // Start Gauge Options //
                    gaugeOptions = {
                        chart: { type: 'solidgauge' },
                        title: null,
                        pane: {
                            centre: ['10', '120'],
                            size: '120',
                            startAngle: -90,
                            endAngle: 90,
                            background: {
                                backgroundColor:
                                    Highcharts.defaultOptions.legend.backgroundColor || '#EEE',
                                innerRadius: '60%',
                                outerRadius: '100%',
                                shape: 'arc'
                            }
                        },
                        // the value axis
                        yAxis: {
                            // Where the colour changes
                            stops: [
                                [0.5, 'red'], // green
                                [0.75, 'orange'], // yellow
                                [0.99, 'green'] // red
                            ],
                            lineWidth: 2,
                            tickWidth: 2,
                            minorTickInterval: null,
                            tickAmount: 2,
                            title: {
                                y: -70
                            },
                            labels: {
                                y: 9
                            }
                        },

                        plotOptions: {
                            solidgauge: {
                                dataLabels: {
                                    y: 5,
                                    borderWidth: 0,
                                    useHTML: true
                                }
                            }
                        }
                    }; // End Gauge Options

                    /////////////////////////////////////////////////////////////
                    var gaugeChart = Highcharts.chart(gauge_name, Highcharts.merge(gaugeOptions, {
                        yAxis: {
                            min: 0,
                            max: 100,
                            title: {
                                text: gauges[key],
                                align: 'low',
                                textAlign: 'center',
                                style: {
                                    color: 'black',
                                    'font-weight': 'bold',
                                    'font-size': '14px'
                                }
                            }
                        },

                        credits: { enabled: false },

                        series: [{
                            data: [gauge_data_perc],
                            dataLabels: {
                                allowOverlap: true,
                                format:
                                    '<div style="text-align:centre">' +
                                    '<span style="font-size:14px">Total ' + gauge_data + '</span><br/>' +
                                    '<span style="font-size:14px;opacity:0.8">Diff {y}%</span><br/>' +
                                    '<span style="font-size:14px;opacity:0.8">Diff ' + gauge_data_diff + '</span>' +
                                    '</div>'
                            },
                        }]
                    })); // End Gauge Chart
                } // End loop of Gauges
                /////////////////////////////////////// End Gauges ////////////////////////////////////////////

                /////////////////////////////////////// Start Season Graph ///////////////////////////////////
                var parseTime = d3.timeParse("%d-%m-%Y");
                var formatTime = d3.timeFormat("%d-%m-%Y");

                var reading_data = [];
                var strategy_area_data = [];
                var rainfall_data = [];
                var irrigation_data = [];
                var critical_data = {};
                var fullpoint = 0;
                var refill = 0;
                var minReading = undefined;
                var maxReading = undefined;

                period_from = moment(d.period_from);
                period_to = moment(d.period_to);
                parameter_string = d.site_id + '/' + period_from.format('DD-MM-YYYY') + '/' + period_to.format('DD-MM-YYYY');

                $("div[id='report']").append("<h5>Season Graph</h5>");
                var row = '';
                row_id = 'row-' + d.site_id + "-" + d.season + "-graph";
                row += "<div class='row' id='" + row_id + "'></row>"
                $("div[id='report']").append(row);
                var chart_name = 'chart-' + d.site_id + '-' + d.season;
                content = '';
                content += "<figure class='highcharts-figure-season_graph'>"
                content += "<div id='" + chart_name + "' class='chart-season_graph'></div></figure>"
                $("div[id='" + row_id + "']").append(content);

                d3.json('/graphs/api/vsw_reading/' + parameter_string + '/?format=json').then(function(data) {
                    d3.json('/graphs/api/vsw_strategy/' + parameter_string + '/?format=json').then(function(strategy_data) {

                        data.forEach(function(reading) {

                            parsed_date = parseTime(reading.date);
                            if (reading.reading_type.name == "Probe") {
                                rz1 = Math.round(reading["rz1"]);
                                reading_data.push({
                                    x : parsed_date,
                                    y : rz1
                                });
                                rainfall_data.push({
                                    x : parsed_date,
                                    y : reading.rainfall
                                });
                                irrigation_data.push({
                                    x : parsed_date,
                                    y : reading.irrigation_mms
                                });
                                if (minReading === undefined || rz1 < minReading)
                                    minReading = rz1;
                                if (maxReading === undefined || rz1 > maxReading)
                                    maxReading = rz1;
                            } else if (reading.reading_type.name == "Full Point") {
                                fullpoint = Math.round(reading["rz1"]);
                            } else if (reading.reading_type.name == "Refill") {
                                refill = Math.round(reading["rz1"]);
                            }
                        }); // End loop of reading data

                        diff = fullpoint - refill;

                        strategy_data.forEach(function(strategy) {
                            critical_data[strategy.critical_date_type] = strategy.critical_date;

                            var strategyDate = parseTime(strategy.strategy_date);
                            var upper = fullpoint - (diff - diff * strategy.percentage);

                            strategy_area_data.push({
                                x: strategyDate,
                                high: upper,
                                low: upper - diff * 0.5
                            });
                        }); // End strategy data loop

                        // Sort by date (x) implicitly, dont rely on api call being in date order
                        strategy_area_data.sort((a, b) => a.x - b.x);
                        reading_data.sort((a, b) => a.x - b.x);
                        rainfall_data.sort((a, b) => a.x - b.x);
                        irrigation_data.sort((a, b) => a.x - b.x);

                        maxY = 0;
                        minY = 0;
                        if (maxReading >= fullpoint){ maxY = maxReading } else { maxY = fullpoint }
                        if (minReading <= refill){ minY = minReading } else { minY = refill }

                        var options = {
                            title: null,
                            credits: { enabled: false },
                            chart: {
                                title: 'Season',
                                renderTo: 'season_graph',
                                type: 'area',
                                height: 400,
                                width: 900
                            },
                            xAxis: {
                              type: 'datetime',
                              plotLines: [],
                            },
                            yAxis: [{
                                title: { text: 'Soil Water Content (mm)' },
                                min: minY,
                                max: maxY,
                                plotLines: [{
                                  value: fullpoint,
                                  color: 'green',
                                  width: 2,
                                  label: { text: 'Full Point' },
                                },
                                {
                                  value: refill,
                                  color: 'red',
                                  width: 2,
                                  label: { text: 'Refill' },

                                }],
                            },
                            {
                                title: { text: 'Rain (mm)' },
                                opposite: true
                            }],
                            plotOptions: {
                              series: {
                                states: {
                                  inactive: {
                                    opacity: 1
                                  }
                                }
                              },
                              column: {
                                pointPadding: 0,
                                groupPadding: 0
                              }
                            },
                            series: [
                                {
                                  name: 'Readings',
                                  type: 'line',
                                  data: reading_data,
                                  yAxis: 0,
                                  color: 'black',
                                  marker: {
                                    enabled: true,
                                    symbol: 'circle',
                                    fillColor: 'black'
                                  },
                                  tooltip: {
                                    valueSuffix: ' mm',
                                    valueDecimals: 1
                                  }
                              },
                              {
                                name: 'Strategy',
                                type: 'arearange',
                                data: strategy_area_data,
                                yAxis: 0,
                                marker: {
                                  enabled: false
                                },
                                color: '#9dc8f1',
                                fillOpacity: 0.5,
                                tooltip: {
                                  valueSuffix: ' mm',
                                  valueDecimals: 1
                                }
                              },
                        ]}; // end options
                        options.xAxis.plotLines = [];
                        for (const criticalDateType in critical_data) {
                            options.xAxis.plotLines.push({
                                value: parseTime(critical_data[criticalDateType]),
                                label: { text: criticalDateType }
                            });
                        }

                        options.series.push({
                          name: 'Rainfall',
                          type: 'column',
                          color: 'blue',
                          data: rainfall_data,
                          yAxis: 1,
                          tooltip: {
                            valueSuffix: ' mm',
                            valueDecimals: 1
                          }
                        },
                        {
                          name: 'Irrigation',
                          type: 'column',
                          color: 'red',
                          data: irrigation_data,
                          yAxis: 1,
                          tooltip: {
                            valueSuffix: ' mm',
                            valueDecimals: 1
                          }
                        })

                        var chart = new Highcharts.Chart(chart_name, options)

                    }); // End json strategy call
                }); // End json reading call

            }); // End loop of data
        }
    });
});
</script>

{% endblock content %}
