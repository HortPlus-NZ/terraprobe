
{% load static %}

{% block content %}

<figure class="highcharts-figure-season_graph">
    <div id="container-season_graph"></div>

</figure>

<script src="https://code.highcharts.com/highcharts.js"></script>
<script src="https://code.highcharts.com/highcharts-more.js"></script>
<script src="https://code.highcharts.com/modules/exporting.js"></script>
<script src="https://code.highcharts.com/modules/export-data.js"></script>
<script src="https://code.highcharts.com/modules/accessibility.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js" charset="utf-8"></script>
<script>

console.clear();

var parseTime = d3.timeParse("%d-%m-%Y");

var reading_data = [];
var strategy_area_data = [];
var rainfall_data = [];
var irrigation_data = [];
var critical_data = {};
var fullpoint = 0;
var refill = 0;
var minReading = undefined;
var maxReading = undefined;

d3.json('/graphs/api/vsw_reading/14/14-10-2019/29-04-2020/?format=json').then(function(data) {
    d3.json('/graphs/api/vsw_strategy/14/14-10-2019/29-04-2020/?format=json').then(function(strategy_data) {

    data.forEach(function(reading) {
        parsed_date = parseTime(reading.date);
        if (reading.reading_type.name == "Probe") {
            rz1 = Math.round(reading["rz1"]);
            reading_data.push({
                x : parsed_date,
                y : rz1
            });
            rainfall_data.push({
                x : parsed_date,
                y : reading.rain
            });
            irrigation_data.push({
                x : parsed_date,
                y : reading.irrigation_mms
            });
            if (minReading === undefined || rz1 < minReading)
                minReading = rz1;
            if (maxReading === undefined || rz1 > maxReading)
                maxReading = rz1;
        } else if (reading.reading_type.name == "Full Point") {
            fullpoint = Math.round(reading["rz1"]);
        } else if (reading.reading_type.name == "Refill") {
            refill = Math.round(reading["rz1"]);
        }
    }); // End loop of reading data

    diff = fullpoint - refill;

    strategy_data.forEach(function(strategy) {
        critical_data[strategy.critical_date_type] = strategy.critical_date;

        var strategyDate = parseTime(strategy.strategy_date);
        var upper = fullpoint - (diff - diff * strategy.percentage);

        strategy_area_data.push({
            x: strategyDate,
            high: upper,
            low: upper - diff * 0.5
        });
    }); // End strategy data loop

    // Sort by date (x) implicitly, dont rely on api call being in date order
    strategy_area_data.sort((a, b) => a.x - b.x);
    reading_data.sort((a, b) => a.x - b.x);
    rainfall_data.sort((a, b) => a.x - b.x);
    irrigation_data.sort((a, b) => a.x - b.x);
    console.log(rainfall_data)
    maxY = 0;
    minY = 0;
    if (maxReading >= fullpoint){ maxY = maxReading } else { maxY = fullpoint }
    if (minReading <= refill){ minY = minReading } else { minY = refill }

    var options = {
        chart: {
            title: 'Season',
            renderTo: 'container-season_graph',
            type: 'area',
            height: 400,
            width: 900
        },
        xAxis: {
          type: 'datetime',
          plotLines: [],
        },
        yAxis: [{
            title: { text: 'Soil Water Content (mm)' },
            min: minY,
            max: maxY,
            plotLines: [{
              value: fullpoint,
              color: 'green',
              width: 2,
              label: { text: 'Full Point' },
            },
            {
              value: refill,
              color: 'red',
              width: 2,
              label: { text: 'Refill' },

            }],
        },
        {
            title: { text: 'Rain (mm)' },
            opposite: true
        }],
        plotOptions: {
          series: {
            states: {
              inactive: {
                opacity: 1
              }
            }
          },
          column: {
            pointPadding: 0,
            groupPadding: 0
          }
        },
        series: [
            {
              name: 'Readings',
              type: 'line',
              data: reading_data,
              yAxis: 0,
              color: 'black',
              marker: {
                enabled: true,
                symbol: 'circle',
                fillColor: 'black'
              },
              tooltip: {
                valueSuffix: ' mm',
                valueDecimals: 1
              }
          },
          {
            name: 'Strategy',
            type: 'arearange',
            data: strategy_area_data,
            yAxis: 0,
            marker: {
              enabled: false
            },
            color: '#9dc8f1',
            fillOpacity: 0.5,
            tooltip: {
              valueSuffix: ' mm',
              valueDecimals: 1
            }
          },
    ]}; // end options
    options.xAxis.plotLines = [];
    for (const criticalDateType in critical_data) {
        options.xAxis.plotLines.push({
            value: parseTime(critical_data[criticalDateType]),
            label: { text: criticalDateType }
        });
    }

    options.series.push({
      name: 'Rainfall',
      type: 'column',
      color: 'blue',
      data: rainfall_data,
      yAxis: 1,
      tooltip: {
        valueSuffix: ' mm',
        valueDecimals: 1
      }
    },
    {
      name: 'Irrigation',
      type: 'column',
      color: 'red',
      data: irrigation_data,
      yAxis: 1,
      tooltip: {
        valueSuffix: ' mm',
        valueDecimals: 1
      }
    })

    var chart = new Highcharts.Chart(options)

}); //end strategy api call
}); //end reading api call

</script>
{% endblock content %}
